==============================
DJANGO IMPORTANT BASICS
 ==============================


 1. WHAT IS UV
 -------------
 -> uv is a **Python package installer and environment manager**, similar to pip but **much faster**.  
 -> It is written in **Rust**, making it extremely optimized and memory-efficient.  
 -> Features:
    - Creates virtual environments
    - Installs packages faster than pip
    - Compatible with existing pip workflows
    - Handles dependency resolution efficiently
 -> Example usage:
    uv venv               -> Create virtual environment
    uv pip install django -> Install Django inside uv environment
 
 

 2. TEMPLATE ENGINE
 ------------------
 -> A template engine is a tool that allows combining **backend data (Python code)** with **frontend HTML/CSS/JS**.  
 -> In Django, template engines are used to render HTML pages dynamically with data passed from views.  
 
 -> Workflow:
    1. Backend (views.py) passes data as a dictionary (called **context**)  
    2. Template engine takes HTML + context data  
    3. Final dynamic HTML page is generated and sent to browser  
 
 -> Django supports multiple template engines:
    - Django Template Language (DTL)
    - Jinja2 (faster and flexible)
    - Others can be configured
 
 

 3. STATIC KEYWORD
 -----------------
 -> {% static '' %} is a **template tag** used in Django to link static files like CSS, JavaScript, or images.  
 -> Example:
    {% load static %}
    <link rel="stylesheet" href="{% static 'css/style.css' %}">
    <img src="{% static 'images/logo.png' %}" alt="Logo">
 
 -> {% load static %}  
    - Must be written at the top of the template to enable static file handling  
    - It tells Django to include the "static" template tag library
 
 

 4. STATIC FILES SETTINGS
 ------------------------
 -> In settings.py, configure static files:
 
    import os
 
    STATIC_URL = 'static/'  
    STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]  
 
 -> Explanation:
    - STATIC_URL : URL endpoint to access static files in templates  
    - STATICFILES_DIRS : List of directories where Django will look for static files in development mode  
    - BASE_DIR : The root directory of the project (auto-defined in settings.py)  
 
 -> Folder structure:
    project/
    ├── static/
    │   ├── css/
    │   │   └── style.css
    │   └── js/
    │       └── script.js
    └── templates/
        └── index.html
 

 
 5. TEMPLATE ENGINE : JINJA2
 ---------------------------
 -> Jinja2 is an alternative template engine supported by Django.  
 -> Features:
    - **Faster** than Django Template Language (DTL)  
    - Syntax is similar but more **Pythonic**  
    - More flexible (supports macros, filters, expressions)  
 
 -> Example (Jinja2 vs DTL):
    DTL:
      {% for user in users %}
         <p>{{ user.name }}</p>
      {% endfor %}
 
    Jinja2:
      {% for user in users -%}
         <p>{{ user.name }}</p>
      {% endfor %}
 
 -> Jinja2 Advantages:
    ✔ Faster rendering speed  
    ✔ More powerful filters and expressions  
    ✔ Better integration for complex projects  
 
 -> Use case:
    - By default, Django uses DTL  
    - But Jinja2 can be enabled for projects requiring performance and advanced templating



 6. REGISTERING MODEL IN ADMIN PANEL
 -----------------------------------
 -> To manage models in Django’s admin interface, we must register them.  
 -> Example:
      from django.contrib import admin
      from .models import ChaiVariety
 
      admin.site.register(ChaiVariety)
 
 -> STEPS TO USE ADMIN:
    1. Create a superuser (admin account):
         python manage.py createsuperuser
         (enter username, email, password)
 
    2. Run the server:
         python manage.py runserver
 
    3. Visit:
         http://127.0.0.1:8000/admin/
 
    4. Login with superuser credentials
 
    5. Now the registered model (ChaiVariety) will appear in the admin panel for **CRUD operations**.
 
 -> We can also customize admin with **ModelAdmin**:
      class ChaiVarietyAdmin(admin.ModelAdmin):
          list_display = ('name', 'price', 'available')
      admin.site.register(ChaiVariety, ChaiVarietyAdmin)
 
 
 7. USING TAILWIND CSS WITH DJANGO
 ---------------------------------
 -> For Tailwind integration, add the following in settings.py:
 
    INSTALLED_APPS = [
        'tailwind',
        'theme',
        ...
    ]
 
    TAILWIND_APP_NAME = 'theme'
    INTERNAL_IPS = ['127.0.0.1']
 
 -> In template:
    {% load static tailwind_tags %}   -> at the top  
    {% tailwind_css %}               -> at the bottom  
 
 -> Commands to set up Tailwind:
    python manage.py tailwind init        -> Initialize Tailwind project
    python manage.py tailwind install     -> Install dependencies
    python manage.py tailwind build       -> Build CSS
    python manage.py tailwind start       -> Start watching for changes
 
 
 8. DYNAMIC URLS & get_object_or_404
 -----------------------------------
 -> Example function in views.py:
      from django.shortcuts import get_object_or_404, render
      from .models import ChaiVariety
 
      def chai_detail(request, chai_id):
          chai = get_object_or_404(ChaiVariety, pk=chai_id)
          return render(request, 'chai/chai_detail.html', {'chai': chai})
 
 -> URL mapping in urls.py:
      path('<int:chai_id>/', views.chai_detail, name="chai_detail")
 
 -> Explanation:
    - <int:chai_id> : Captures an integer from URL and passes it as chai_id  
    - get_object_or_404 : Fetches object from DB, if not found → returns 404 error  
    - 'chai' : key to pass data to template  
 
 -> In template:
      <a href="{% url 'chai_detail' i.id %}">
    - {% url 'chai_detail' i.id %} generates a dynamic link for each chai item  
 
 
 9. STATIC FILES VS MEDIA FILES
 ------------------------------
 -> STATIC FILES:
    - Files that **don’t change** during runtime
    - Examples: CSS, JS, images for UI
    - Settings:
        STATIC_URL = 'static/'
        STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]
 
 -> MEDIA FILES:
    - Files **uploaded by users/admin**
    - Examples: Profile pictures, documents, product images
    - Settings:
        MEDIA_URL = '/media/'
        MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
 
 -> To serve media files during development:
    Add this in urls.py:
        from django.conf import settings
        from django.conf.urls.static import static
 
        urlpatterns = [
            ...
        ] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
 
 
 10. IMAGE FIELD IN DJANGO MODEL
 -------------------------------
 -> To store images in Django models, use **ImageField**:
      from django.db import models
 
      class Profile(models.Model):
          name = models.CharField(max_length=100)
          profile_pic = models.ImageField(upload_to='profile_pics/')
 
 -> Explanation:
    - upload_to='profile_pics/' : Uploaded images stored in MEDIA_ROOT/profile_pics/
 
 -> Settings required:
    MEDIA_URL = '/media/'
    MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
 
 -> Commands needed:
    1. Install Pillow (required for image processing)
         pip install Pillow
 
    2. Make migrations:
         python manage.py makemigrations
         python manage.py migrate
 
 -> Usage in template:
      <img src="{{ user.profile_pic.url }}" alt="Profile Picture">



 11. DIFFERENCE BETWEEN request.GET['num1'] VS request.GET.get('num1')
 --------------------------------------------------------------------
 -> request.GET['num1']
    - Direct dictionary-style access
    - If 'num1' key is NOT present in the request → throws **KeyError**
    - Example:
         value = request.GET['num1']   # Crashes if num1 is missing
 
 -> request.GET.get('num1')
    - Safer way to access query parameters
    - If 'num1' does NOT exist → returns **None** instead of crashing
    - Can also provide a default value:
         value = request.GET.get('num1', 0)
 
 -> USAGE RULE:
    - Use request.GET['key'] when you are SURE the parameter exists
    - Use request.GET.get('key') when the parameter may/may not exist
 
 
 12. IMPLEMENTING GET, POST, REDIRECTS IN FORMS
 ----------------------------------------------
 -> Django supports multiple HTTP methods (GET, POST, PUT, DELETE)
    but most commonly used in forms → **GET and POST**
 
 -> EXAMPLE FORM (template):
      <form method="POST" action="/chai/">
          {% csrf_token %}
          <input type="text" name="num1">
          <input type="text" name="num2">
          <button type="submit">Submit</button>
      </form>
 
 -> VIEWS (example):
      from django.http import HttpResponseRedirect
 
      def chai_sum(request):
          if request.method == "POST":
              num1 = int(request.POST.get('num1'))
              num2 = int(request.POST.get('num2'))
              total = num1 + num2
              # Redirect with result
              return HttpResponseRedirect(("/chai/?output={}").format(total))
 
          return render(request, 'chai/form.html')
 
 -> REDIRECTION:
    - HttpResponseRedirect is used to send user to another URL
    - Data can be passed as query params (?output=value)
    - Example redirect URL:
         /chai/?output=30
 
 -> RETRIEVING DATA AFTER REDIRECT:
      def result(request):
          output = request.GET.get('output')
          return render(request, 'chai/result.html', {'output': output})
 
 
 13. CSRF PROTECTION IN DJANGO
 -----------------------------
 -> CSRF = Cross-Site Request Forgery
 -> It is an attack where a malicious website tricks a logged-in user
    into performing unwanted actions on another site.
 
 -> DJANGO’S CSRF PROTECTION:
    - Django provides built-in **csrf_token** middleware
    - Every POST form must include a hidden CSRF token field
    - Example in template:
         <form method="POST">
             {% csrf_token %}
             ...
         </form>
 
 -> HOW CSRF WORKS (Step-by-Step):
    1. User visits a Django form page  
       → Django generates a **unique CSRF token** for that session  
 
    2. Token is embedded in the HTML form via `{% csrf_token %}`  
 
    3. When the form is submitted (POST request)  
       → Browser sends CSRF token along with request  
 
    4. Django compares:
         - Token in request header/body
         - Token stored in session/cookie  
 
    5. If both match → request is VALID  
       If mismatch → Django raises **403 Forbidden (CSRF verification failed)**  
 
 -> WORKFLOW (VISUALIZED):
    [User Request] → [Form with CSRF token] → [Submit Form]  
    → [CSRF token validated in backend] → [Accept or Reject request]
 
 -> WHY IT’S IMPORTANT:
    - Prevents attackers from forcing user actions unknowingly
    - Protects sensitive operations like payments, form submissions, account changes



 14. DIFFERENCE BETWEEN FORMAL HTML FORM AND DJANGO FORMS
 --------------------------------------------------------
 -> FORMAL HTML FORM:
    - Written manually in HTML
    - Validation done in JS or backend manually
    - Example:
         <form method="POST">
             <input type="number" name="num1" placeholder="Enter Value1" required>
             <button type="submit">Submit</button>
         </form>
    - Developer must handle:
         * Validation
         * Error messages
         * CSRF protection manually
 
 -> DJANGO FORMS:
    - Created using Python classes (forms.Form or forms.ModelForm)
    - Automatically generate HTML inputs
    - Built-in validation and error handling
    - CSRF protection included automatically
 
 -> Example (Custom Form with widgets):
      from django import forms
 
      class ModelForm(forms.Form):
          num1 = forms.IntegerField(
              label="Value1",
              max_value=1001,
              required=True,
              widget=forms.NumberInput(attrs={
                  "id": "num1",
                  "class": "w-full text-black border border-gray-300 rounded-md px-3 py-2 "
                           "focus:outline-none focus:ring-2 focus:ring-orange-400 focus:border-orange-400",
                  "placeholder": "Enter Value1"
              })
          )
 
 -> Key Points:
    - Fields:
        * CharField, IntegerField, FloatField, DecimalField, BooleanField, EmailField, URLField, ChoiceField, MultipleChoiceField, DateField, DateTimeField, FileField, ImageField, etc.
    - Widgets:
        * Define **HTML representation** of the field
        * Examples: TextInput, NumberInput, EmailInput, PasswordInput, Select, CheckboxInput, FileInput, Textarea
        * Customize CSS, placeholder, ID, class, attributes via `attrs` dictionary
    - Validation:
        * Required, min_value, max_value, max_length, regex validation, custom validators
    - Advantages:
        * Less repetitive code
        * Centralized validation
        * Easy integration with models (ModelForm)
 
 
 
 15. HOW TO RENDER DJANGO FORMS
 -------------------------------
 -> Way 1: Simple render
      {{ form }}
    - Renders the **entire form** with all fields and errors automatically
    - Quick and convenient
    - Limited styling control
 
 -> Way 2: Field-wise rendering (for custom styling)
      {% for field in form %}
          <div class="fieldWrapper">
              {{ field.errors }}
              {{ field.label_tag }} {{ field }}
          </div>
      {% endfor %}
    - Allows **custom HTML and CSS per field**
    - Useful for Tailwind, Bootstrap, or custom designs
 
 -> Other ways to render:
    1. Using **as_p**, **as_table**, **as_ul**:
         {{ form.as_p }}      -> wraps each field in <p>  
         {{ form.as_table }}  -> renders as table rows  
         {{ form.as_ul }}     -> renders as <li> elements  
 
    2. Access individual fields:
         {{ form.num1 }}      -> renders only num1 input
         {{ form.num1.errors }} -> shows errors for num1
 
    3. Rendering non-field errors:
         {{ form.non_field_errors }}  -> useful for form-level validation
 
 -> Field Types in Django Forms (summary):
    - CharField, IntegerField, FloatField, DecimalField  
    - BooleanField, NullBooleanField, ChoiceField, MultipleChoiceField  
    - DateField, DateTimeField, TimeField  
    - EmailField, URLField, FileField, ImageField  
    - SlugField, RegexField, TypedChoiceField, ModelChoiceField, ModelMultipleChoiceField
 
 -> Widget Customization:
    - Use widgets to customize attributes:
         widget=forms.TextInput(attrs={"class": "input", "placeholder": "Enter text"})
    - Can assign CSS classes, placeholder, id, type, style
    - Example: PasswordInput for password fields:
         password = forms.CharField(widget=forms.PasswordInput(attrs={"placeholder": "Enter Password"}))